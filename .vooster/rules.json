{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 요약\n소규모 팀을 위한 멀티플랫폼(웹·모바일·데스크톱) 업무 관리 SaaS이다. 팀원들은 할 일(TODO)과 업무(Task)를 손쉽게 등록·분담·추적할 수 있으며, 그리드·칸반·간트 차트 뷰를 통해 직관적으로 진행 상황을 확인한다. 서비스는 monday.com 수준의 협업 기능을 한국·베트남 혼합 팀에 최적화하여, 업무 누락을 방지하고 프로젝트 완료율을 향상시킨다.\n\n## 2. 문제 정의\n- 소규모 글로벌 팀은 업무 파편화로 인해 진행률 가시성이 부족하다.  \n- 한국인 주재원과 베트남 중간 관리자는 언어·문화차로 커뮤니케이션 오류가 발생한다.  \n- 기존 대형 SaaS는 비용이 높거나 현지화가 미흡하여 도입 장벽이 크다.  \n\n## 3. 목표 및 목적\n- 1차 목표: 간단·저비용으로 팀 업무를 체계화하고 실시간 진행률을 시각화  \n- 2차 목표: 다국어 UI·알림으로 협업 혼선을 최소화, 데이터 기반 업무 분석 제공  \n- 성공 지표  \n  - 주간 활성팀 비율 60% 이상  \n  - 사용자당 평균 완료 Task 20%↑(3개월 내)  \n  - 온보딩 1주 내 이탈률 15% 이하  \n  - 평균 페이지 응답 ≤1초, 가용성 99.9%\n\n## 4. 타깃 사용자\n### 1차 사용자\n- 20~40대 한국 주재원·베트남 중간 관리자  \n- IT·제조 등 최대 30명 이하 조직  \n- 업무 분담·데드라인 관리 니즈, 모바일 우선 사용  \n### 2차 이해관계자\n- 경영진: 팀 생산성 지표 확보  \n- HR·PMO: 프로젝트 성과 모니터링\n\n## 5. 사용자 스토리\n- “팀 리더로서, 각 팀원의 업무를 칸반 보드에서 드래그해 진행 단계를 즉시 수정하고 싶다.”  \n- “개발자로서, 마감 임박 Task 알림을 모바일로 받아 놓치지 않길 원한다.”  \n- “PM으로서, 프로젝트 전체 일정을 간트 차트로 확인해 리소스를 재조정하고 싶다.”  \n- “베트남 직원으로서, 한국어로 작성된 Task를 자동 번역된 베트남어로 보고 싶다.”  \n- “경영진으로서, 월간 완료율·지연율을 대시보드로 파악해 병목을 개선하고 싶다.”  \n\n## 6. 기능 요구사항\n### 핵심 기능\n1. Task/TODO CRUD  \n   - 생성 시 제목·설명·담당자·우선순위·마감일 필수  \n   - 편집·삭제는 작성자·관리자만 가능  \n   - 조건: 저장 500ms 이내, 동시 편집 충돌 방지  \n2. 그리드 뷰  \n   - 엑셀 유사 행·열 편집, 다중 선택·일괄 수정 지원  \n   - 필터·정렬·검색 50ms 이내  \n3. 칸반 뷰  \n   - 단계 컬럼 자유 생성, Drag & Drop 이동  \n   - WIP(Work In Progress) 제한 설정  \n4. 간트 차트 뷰  \n   - Task 간 종속 관계 설정, 지연 시 즉시 경고  \n   - 스크롤·줌으로 주/월/분기 단위 전환  \n5. 팀 협업  \n   - 멘션(@) 기반 댓글, 파일 첨부(최대 100MB), 버전 관리  \n   - 다국어(한국어·베트남어) UI 토글, 실시간 번역 API 연동  \n6. 알림·리마인더  \n   - 마감 24h 전, 상태 변경 시 Push·Email·In-App 알림  \n   - 사용자가 채널·빈도 설정 가능  \n7. 권한 관리  \n   - 관리자/편집자/뷰어 역할, 프로젝트별 접근 제어  \n8. 대시보드  \n   - 완료율, 지연률, 워크로드 차트, CSV 내보내기  \n\n### 지원 기능\n- OAuth(Google, Microsoft) 로그인  \n- 다크 모드·접근성(색맹 팔레트)  \n- 오프라인 캐싱(PWA)  \n- Slack·Teams·KakaoTalk 통합 알림  \n- 캘린더 연동(Google Calendar, Outlook)  \n- API 공개(REST·GraphQL)  \n\n## 7. 비기능 요구사항\n- 성능: 10k Task 데이터셋 로드 2초 이내  \n- 보안: OAuth2, JWT, AES-256 at-rest, GDPR & ISO 27001 준수  \n- 사용성: NPS 40+ 목표, 모바일 우선 디자인  \n- 확장성: 멀티 테넌트, 수평 확장(쿠버네티스)  \n- 호환성: Chrome 90+, Edge, Safari, iOS 14+, Android 10+, Windows/Mac 데스크톱  \n\n## 8. 기술 고려\n- 프런트엔드: React + TypeScript, Redux Toolkit, React Query  \n- 모바일: React Native, Expo OTA 업데이트  \n- 데스크톱: Electron wrapper(PWA 기반)  \n- 백엔드: Node.js(NestJS), GraphQL Gateway, REST fallback  \n- 데이터베이스: PostgreSQL(파티셔닝), Redis 캐시  \n- 인프라: AWS EKS, RDS, S3, CloudFront, SNS  \n- CI/CD: GitHub Actions → Docker → ArgoCD  \n- 번역: Google Cloud Translation API  \n- 통합: Slack, Microsoft Teams Webhook, REST Webhook  \n- 로깅/모니터링: ELK Stack, Prometheus + Grafana  \n- 데이터 백업: 하루 1회 스냅샷, 30일 보존  \n\n## 9. 성공 지표\n- 월간 활성팀(MAT) ≥ 500  \n- DAU/MAU ≥ 40%  \n- Task 완료율 80% 이상 유지  \n- 평균 서버 오류율(5xx) < 0.1%  \n- 고객 지원 티켓 응답 ≤4h  \n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| 1. 기획 확정 | T0~T0+2주 | 요구사항 동결, UX Wireframe |\n| 2. MVP 개발 | T0+3주~T0+11주 | 핵심 기능 1~6, 단일 언어(한국어) |\n| 3. MVP 베타 | T0+12주 | 클로즈드 베타, 피드백 수집 |\n| 4. 멀티랭귀지 & 모바일 | T0+13주~T0+19주 | 베트남어 UI, React Native 앱 |\n| 5. GA 출시 | T0+20주 | 공개 론칭, 마케팅 캠페인 |\n| 6. V1.5 확장 | T0+28주 | 대시보드, API 공개, Slack 통합 |\n\n## 11. 위험 및 대응\n- 기술: 실시간 동시 편집 충돌 → OT(Operational Transformation) 라이브러리 적용  \n- 비즈니스: 타 SaaS 대비 차별성 부족 → 현지화, 저가 요금제 도입  \n- 사용성: 다국어 번역 품질 → 사용자 커스텀 번역 편집 기능 제공  \n- 데이터: 장애 시 업무 중단 → 다중 AZ, 자동 장애 조치, 오프라인 캐시  \n\n## 12. 향후 로드맵\n- AI 기반 Task 예측 마감일, 지연 알림  \n- 업무 템플릿 마켓플레이스  \n- OKR·KPI 연계 모듈  \n- SSO(SAML, SCIM) Enterprise 플랜  \n- 로컬 설치형 패키지(온프레미스) 공급  \n- 파트너사 연동 SDK 및 개발자 포털 구축",
      "writedAt": "2025-07-19T13:56:55.456Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  소규모 한국·베트남 혼합 팀을 위한 멀티플랫폼 업무 관리 SaaS로, 웹·모바일·데스크톱에서 할 일(TODO)과 업무(Task)를 등록·분담·추적. 그리드·칸반·간트 차트를 통해 실시간 진행률 시각화. 다국어 UI·알림으로 협업 혼선 최소화.\n- **핵심 기술 스택**  \n  프런트엔드: React, TypeScript, Redux Toolkit, React Query  \n  모바일: React Native (Expo)  \n  데스크톱: Electron(PWA 기반)  \n  백엔드: Node.js (NestJS), GraphQL Gateway + REST Fallback  \n  데이터베이스: PostgreSQL (파티셔닝), Redis  \n  인프라: AWS EKS, RDS, S3, CloudFront, SNS  \n  CI/CD: GitHub Actions → Docker → ArgoCD  \n  로깅/모니터링: ELK Stack, Prometheus + Grafana  \n  번역 API: Google Cloud Translation  \n- **주요 기술 목표**  \n  • 평균 페이지 응답 ≤1초, 가용성 99.9% 유지  \n  • 동시 편집 충돌 방지(OT 기반 실시간 협업)  \n  • 대규모(10k Task) 데이터 로드 2초 이내  \n- **핵심 가정**  \n  • 멀티 테넌트 구조로 확장 가능, 수평 확장(EKS)  \n  • 모바일 우선 디자인, PWA 기능 활용  \n  • 다국어 지원은 한국어·베트남어부터 순차 확장  \n\n## 2. Tech Stack\n\n| Category        | Technology / Library                | Reasoning                                       |\n| --------------- | ----------------------------------- | ----------------------------------------------- |\n| Frontend        | React, TypeScript                   | 재사용성·유지보수성 높고 커뮤니티 지원 풍부     |\n| State Management| Redux Toolkit                        | 간단한 상태 관리, 비동기 로직 처리 용이         |\n| Data Fetching   | React Query                         | 서버 상태 캐싱·동기화 최적화                    |\n| Mobile          | React Native, Expo                  | 단일 코드베이스로 iOS·Android 지원, OTA 업데이트|\n| Desktop         | Electron (PWA 기반)                 | 기존 웹 코드 재활용, 크로스플랫폼 배포 간편      |\n| Backend         | Node.js, NestJS                     | 구조화된 아키텍처, 모듈화·테스트 용이           |\n| API             | GraphQL Gateway, REST Fallback      | 유연한 클라이언트 요구, 이중 접근 지원           |\n| Database        | PostgreSQL (파티셔닝)               | 관계형 데이터 정합성 보장, 대규모 데이터 처리   |\n| Cache           | Redis                                | 세션·실시간 편집 협업 상태, 캐싱 속도 최적화    |\n| Infrastructure  | AWS EKS, RDS, S3, CloudFront, SNS   | 관리형 서비스 활용, 수평 확장 및 글로벌 배포 최적|\n| CI/CD           | GitHub Actions, Docker, ArgoCD      | 자동화 파이프라인 구축, 빠른 배포               |\n| Monitoring      | ELK Stack, Prometheus + Grafana     | 로그·메트릭 통합 모니터링                       |\n| Translation API | Google Cloud Translation API        | 안정적 번역 품질, REST 기반 간편 연동           |\n| Integration     | Slack, Microsoft Teams, KakaoTalk   | 주요 협업 툴 연동, Webhook 기반 간편 구현       |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- 프런트엔드 애플리케이션  \n  • React 기반 SPA, React Query로 데이터 페칭  \n  • 다국어 UI 토글 및 실시간 번역 API 연동  \n- 모바일 애플리케이션  \n  • Expo 기반 React Native, PWA 오프라인 캐싱  \n- 데스크톱 애플리케이션  \n  • Electron 래퍼, 내부 PWA 로딩  \n- 백엔드 서비스  \n  • NestJS 기반 GraphQL Gateway, REST 엔드포인트  \n  • OT(Operational Transformation) 협업 모듈  \n- 데이터 저장소  \n  • PostgreSQL (파티셔닝), Redis 캐시  \n- 외부 통합 서비스  \n  • Google Cloud Translation, OAuth(Google/Microsoft)  \n  • Slack·Teams·KakaoTalk 알림 Webhook  \n- 인프라 & 배포  \n  • AWS EKS(컨테이너 오케스트레이션), RDS, S3, CloudFront, SNS  \n  • CI/CD: GitHub Actions → Docker → ArgoCD  \n- 로깅·모니터링  \n  • ELK Stack 로그 저장, Prometheus 메트릭 + Grafana 대시보드  \n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    FE[웹 프런트엔드] --> API[GraphQL Gateway]\n    MB[모바일 앱] --> API\n    DT[데스크톱 앱] --> API\n    API --> BE[비즈니스 로직 (NestJS)]\n    BE --> DB[PostgreSQL]\n    BE --> REDIS[Redis 캐시]\n    BE --> EXT[외부 서비스 (Translation, OAuth, Webhook)]\n```\n- 웹·모바일·데스크톱 클라이언트는 GraphQL Gateway를 통해 백엔드 비즈니스 로직에 요청  \n- NestJS 비즈니스 계층은 PostgreSQL·Redis로 데이터 조회·캐싱  \n- 번역·알림·OAuth는 외부 서비스와 REST/Webhook 연동  \n- CI/CD 파이프라인은 Docker 이미지를 AWS EKS에 배포  \n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**  \n- Domain Separation: user, task, board, notification, dashboard, collaboration  \n- Layer-Based Architecture: presentation (controller/resolver) → service → repository  \n- Feature-Based Modules: 각 도메인별 NestJS 모듈  \n- Shared Components: 공통 유틸·데이터 타입·인터셉터·필터\n\n**Universal File & Folder Structure**\n```\n/\n├── apps\n│   ├── web-app                   # React 프런트엔드\n│   ├── mobile-app                # React Native (Expo)\n│   └── desktop-app               # Electron 래퍼\n├── services\n│   ├── api-gateway               # GraphQL Gateway + REST\n│   ├── auth-service              # OAuth, JWT\n│   ├── task-service              # Task/TODO 관리\n│   ├── board-service             # 그리드·칸반·간트 로직\n│   └── notification-service      # Push/Email/In-App 알림\n├── libs\n│   ├── shared-types              # 공통 타입 정의\n│   ├── shared-utils              # 공통 유틸리티\n│   └── ot-collab                 # Operational Transformation 라이브러리\n├── infra\n│   ├── k8s                       # 쿠버네티스 매니페스트\n│   ├── terraform                 # AWS 인프라 코드\n│   └── argocd                    # ArgoCD 설정\n├── scripts\n│   └── migrate                   # DB 마이그레이션 스크립트\n└── .github\n    └── workflows                 # GitHub Actions CI 설정\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: GraphQL 쿼리/뮤테이션, WebSocket(협업 실시간 동기화)  \n- **Database Interaction**: TypeORM 또는 Prisma ORM 사용, 파티셔닝 전략 적용  \n- **External Service Integration**: RESTful Webhook, Google Translation API 호출 비동기 처리  \n- **Real-time Communication**: WebSocket 기반 OT 협업 이벤트 브로드캐스트  \n- **Data Synchronization**: CQRS 패턴 고려, Redis Pub/Sub을 통한 이벤트 전파  \n\n## 4. Performance & Optimization Strategy\n- 쿼리 최적화: 인덱스·파티셔닝, N+1 문제 해결을 위한 DataLoader 사용  \n- 캐싱 전략: Redis를 활용한 빈번 조회 데이터 및 OT 세션 캐시  \n- 지연 경고: 간트 차트 종속성 변경 시 서버 사이드 계산 후 즉각 알림  \n- CDN 활용: CloudFront로 정적 자산 전송, S3 버전 관리  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- Core Infrastructure: EKS 클러스터, RDS, 기본 네트워크  \n- Essential Features: Task CRUD, 그리드·칸반 뷰, 기본 권한 관리  \n- Basic Security: OAuth2, JWT 인증, AES-256 at-rest  \n- Development Setup: GitHub Actions, Docker 이미지 구축  \n- Timeline: 8주\n\n### Phase 2: Feature Enhancement\n- Advanced Features: 간트 차트, 멘션·댓글, 파일 첨부, 다국어(한국어)  \n- Performance Optimization: 캐싱·인덱싱, OT 협업 테스트  \n- Enhanced Security: CSRF, XSS 방어, GDPR 준비  \n- Monitoring Implementation: ELK + Prometheus 대시보드  \n- Timeline: 6주\n\n### Phase 3: Scaling & Optimization\n- Scalability Implementation: 멀티 테넌트 지원, Auto Scaling 설정  \n- Advanced Integrations: Slack·Teams·KakaoTalk 알림, Calendar 연동  \n- Enterprise Features: API 공개(REST·GraphQL), CSV 내보내기  \n- Compliance & Auditing: ISO 27001 감사 준비, 스냅샷 백업 검증  \n- Timeline: 8주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **기술 리스크**: OT 구현 복잡도 → 검증된 오픈소스 라이브러리 활용  \n- **성능 리스크**: 대량 Task 로드 지연 → 파티셔닝·캐싱, 프론트트리거 페이징  \n- **보안 리스크**: JWT 탈취, XSS → HTTPS 강제, CSP, Input Validation  \n- **통합 리스크**: 외부 Webhook 지연/오류 → 재시도 로직, Dead Letter Queue  \n\n### Project Delivery Risks\n- **일정 리스크**: 멀티 플랫폼 동시 개발 → MVP 단계 우선순위 명확화  \n- **리소스 리스크**: OT 전문 지식 부족 → 사전 PoC 및 교육  \n- **품질 리스크**: 테스트 커버리지 부족 → 유닛·통합·E2E 테스트 파이프라인  \n- **배포 리스크**: 버전 호환성 이슈 → 블루/그린 배포 전략  \n- **비상 계획**: 롤백 스크립트, 별도 테스트 클러스터 운영  \n\n---",
      "writedAt": "2025-07-19T13:56:55.457Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-19T13:56:55.457Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-19T13:56:55.457Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-19T13:56:55.457Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-19T13:56:55.457Z"
    }
  ]
}
